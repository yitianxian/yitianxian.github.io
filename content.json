{"meta":{"title":"记录","subtitle":"千里之行，始于足下","description":null,"author":"Z-Q-K","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2021-03-28T08:47:05.000Z","updated":"2021-03-28T08:47:23.285Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-03-28T08:43:33.000Z","updated":"2021-03-28T08:46:27.089Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ts类","slug":"ts类","date":"2021-03-29T08:42:04.000Z","updated":"2021-03-29T09:41:16.575Z","comments":true,"path":"2021/03/29/ts类/","link":"","permalink":"http://yoursite.com/2021/03/29/ts类/","excerpt":"","text":"ts类12345678910111213141516171819202122232425//和java一样(() =&gt; &#123; //父类 class Person &#123; name: string age: number sex: string //可以给默认值 constructor(name: string, age: number=1) &#123; this.name = name this.age = age &#125; say(str:string) &#123; console.log(\"class say no \" + this.name + \" \" + str) &#125; run(distance: number=10) &#123; console.log(this.name + \" run \" + distance) &#125; &#125; var person:Person = new Person(\"zs\") // Person.prototype.sex = \"man\" // //person.sex = \"man\" // console.log(person.sex) //man person.say('father') //class say no zs father&#125;)() 继承12345678910111213141516171819//子类class CPerson extends Person &#123; constructor(name: string, age: number=1) &#123; super(name, age); &#125; say(str:string) &#123; console.log(\"CPerson \" + str) super.say('children') &#125; run(distance: number=100) &#123; console.log(this.name + \" run \" + distance) &#125; &#125; var cp:CPerson = new CPerson(\"ls\") // CPerson.prototype.sex = 'woman' // cp.sex = \"woman\" // console.log(cp.sex) //woman cp.say(\"child\") //CPerson child CPerson class say no ls 多态1234567891011121314151617//父类的引用指向子类对象，不同类型的子类针对相同方法产生不同的行为class CCPerson extends Person &#123; constructor(name: string, age: number=1) &#123; super(name, age); &#125; run(distance: number = 1000) &#123; console.log(this.name + \" run \" + distance) &#125;&#125;var ccp:CCPerson = new CCPerson('ww')var cp1:Person = new CPerson(\"zl\") //使用父类型创建子类对象var ccp1:Person = new CCPerson(\"qq\")person.run() //zs run 10cp.run() //ls run 100ccp.run() //ww run 1000cp1.run() //zl run 100ccp1.run() //qq run 1000 修饰符protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 访问修饰符: 用来描述类内部的属性/方法的可访问性 public: 默认值, 公开的外部也可以访问 private: 只能类内部可以访问 protected: 类内部和子类可以访问*/class Animal &#123; public name: string public constructor (name: string) &#123; this.name = name &#125; public run (distance: number=0) &#123; console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`) &#125;&#125;class Person extends Animal &#123; private age: number = 18 protected sex: string = '男' run (distance: number=5) &#123; console.log('Person jumping...') super.run(distance) &#125;&#125;class Student extends Person &#123; run (distance: number=6) &#123; console.log('Student jumping...') console.log(this.sex) // 子类能看到父类中受保护的成员 // console.log(this.age) // 子类看不到父类中私有的成员 super.run(distance) &#125;&#125;console.log(new Person('abc').name) // 公开的可见// console.log(new Person('abc').sex) // 受保护的不可见// console.log(new Person('abc').age) // 私有的不可见 readonly使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 1234567891011121314class Person &#123; readonly name: string = 'abc' constructor(name: string) &#123; this.name = name &#125;&#125;//参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。class Person &#123; //仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处 constructor(readonly name: string) &#123; this.name = name &#125;&#125; 存取器 getter 和 setter","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"ts接口","slug":"ts接口","date":"2021-03-29T07:37:26.000Z","updated":"2021-03-29T09:31:48.188Z","comments":true,"path":"2021/03/29/ts接口/","link":"","permalink":"http://yoursite.com/2021/03/29/ts接口/","excerpt":"","text":"ts接口TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述) 123456789101112131415// 定义人的接口interface IPerson &#123; readonly id: number //只读 name: string age: number sex？: string //可选属性&#125;const person1: IPerson = &#123; id: 1, name: 'tom', age: 20,&#125;person1.id = 10 //编译不通过person1.sex = 'man' ts函数类型为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 123456789101112131415/* 接口可以描述函数类型(参数的类型与返回的类型)*/interface SearchFunc &#123; //定义一个调用签名 //它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型 (source: string, subString: string): boolean&#125;const mySearch: SearchFunc = function (source: string, sub: string): boolean &#123; return source.search(sub) &gt; -1&#125;console.log(mySearch('abcd', 'bc')) //true 类类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//和java相似 继承 实现/* 类类型: 实现接口1. 一个类可以实现多个接口2. 一个接口可以继承多个接口*/(() =&gt; &#123; //定义一个接口 interface Ifly &#123; //定义一个没有任何实现的方法 fly():void &#125; class Fly implements Ifly &#123; fly() &#123; console.log('fly') &#125; &#125; var fly = new Fly() fly.fly() interface Ifly2 &#123; //定义一个没有任何实现的方法 fly2():void &#125; class Fly2 implements Ifly, Ifly2 &#123; fly() &#123; console.log('fly1') &#125; fly2() &#123; console.log('fly2') &#125; &#125; var fly2 = new Fly2() fly2.fly() fly2.fly2() interface Ifly3 extends Ifly, Ifly2 &#123; &#125; class Fly3 implements Ifly3 &#123; fly() &#123; console.log('fly3') &#125; fly2() &#123; console.log('fly3') &#125; &#125; var fly3 = new Fly3() fly3.fly() fly3.fly2()&#125;)()","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"js数组操作","slug":"js数组操作","date":"2021-03-29T02:37:26.000Z","updated":"2021-03-29T06:53:06.247Z","comments":true,"path":"2021/03/29/js数组操作/","link":"","permalink":"http://yoursite.com/2021/03/29/js数组操作/","excerpt":"","text":"js数组操作常用1234567891011push()：向数组的末尾添加一个或多个元素，并返回新的长度pop()：删除数组的最后一个元素，数组的长度减1，并且返回删除元素的值(数组为空时，不改变数组，并返回undefined)unshift()：向数组的头部添加一个或多个元素，返回新的长度shift()：删除并返回数组的第一个元素reverse()：颠倒数组中的元素顺序indexOf(x, start)、lastIndexOf()：查找数组元素的位置，参数：要查的项和起点位置索引 排序 sort =&gt; 对数组元素进行排序（默认按照ASCII）123456789101112131415161718192021222324252627282930313233343536373839404142434445var arr = [10,5,1000,25,1];arr.sort(); // [1, 10, 1000, 25, 5] 默认按照首字母顺序排arr.sort((a, b)=&gt;&#123; return a-b;&#125;); // [1, 5, 10, 25, 1000] 从大到小排序 /** * @function 指定数组排序规则 * @param str &#123;Array&#125; 单个属性 * @param num &#123;Number&#125; 是否升序 默认降序 * @version 1.0.0 * @description 用于图表的排序 */sortBy() &#123; let num = 1 let arr = [] //最后一个参数是数字 if(typeof arguments[arguments.length - 1] === 'number' &amp;&amp; !isNaN(arguments[arguments.length - 1])) &#123; //获取最后一个参数的值 num = arguments[arguments.length - 1] ? 1 : -1 arr = arguments.slice(0, arguments.length - 1) &#125;else &#123;//最后一个参数不是数字 arr = arguments &#125; // num = num ? 1 : -1 return function(a,b)&#123; // 获取其他参数的值 let a1 = 0 let b1 = 0 for(var i = 0, len = arr.length; i &lt; len; i++) &#123; a1 += a[arr[i]] b1 += b[arr[i]] &#125; if(a1 &gt; b1)&#123; return num * -1; &#125; if(a1 &lt; b1)&#123; return num * 1; &#125; return 0; &#125;&#125;//使用data.sort(this.sortBy('isLeader', 'isNotLeader')) concat()：链接两个或多个数组123456//该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。arrayObject.concat(arrayX,arrayX,......,arrayX)//可用于对数组进行深拷贝 （不行）//数组中的对象等还是没有进行深拷贝var arr1 = [].concat(arr) join =&gt; 把所有的元素放进一个字符串，通过指定的分隔符分割1234var arr = [1,2,3]arr.join('-') //\"1-2-3\"var arr1 = []arr1.join(\"-\")//\"\" splice =&gt; 删除元素，并向数组添加新元素12345678var arr = [1, 2, 3, 4, 5, 6];arr.splice(2, 3); // [3, 4, 5] 删除第三个元素以后的三个数组元素 arr.splice(2, 0, 7, 8); // [] 在第三个元素之前插入7和8arr; // [1, 2, 7, 8, 9] arr.splice(2, 3, 9, 10); // [7, 8, 9] 删除第三个元素以后的三个数组元素，并用9和10代替arr; // [1, 2, 9, 10] slice(start, end) =&gt; 从某个已有的数组返回选定的元素(没有end参数时就到数组结尾)123456789//该方法返回一个新的数组，包含从 start 到 end （不包括该元素，数学上来讲是左闭右开，即包含左，不含右）的 arrayObject 中的元素//可用于数组深拷贝(不行)//不会影响原数组////数组中的对象等还是没有进行深拷贝var arr1 = [1, 2, 3];var arr2 = arr1.slice(0);arr1[0] = 4;console.log(arr1); //4, 2, 3console.log(arr2); //1, 2, 3 深拷贝12345678910111213141516171819function getType(o)&#123; var _t; return ((_t = typeof(o)) == \"object\" ? o==null &amp;&amp; \"null\" || Object.prototype.toString.call(o).slice(8,-1):_t).toLowerCase();&#125;function extend(destination,source)&#123; for(var p in source)&#123; if(getType(source[p])==\"array\"||getType(source[p])==\"object\")&#123; destination[p]=getType(source[p])==\"array\"?[]:&#123;&#125;; arguments.callee(destination[p],source[p]); &#125;else &#123; destination[p]=source[p]; &#125; &#125;&#125;var test=&#123;a:\"ss\",b:\"dd\",c:&#123;d:\"css\",e:\"cdd\"&#125;&#125;;var test1=&#123;&#125;;extend(test1,test);test1.c.d=\"change\"; //改变test1的c属性对象的d属性alert(test.c.d); //不影响test","categories":[],"tags":[{"name":"js 数组","slug":"js-数组","permalink":"http://yoursite.com/tags/js-数组/"}]},{"title":"js遍历数组","slug":"js遍历数组","date":"2021-03-29T02:20:04.000Z","updated":"2021-03-29T02:35:53.414Z","comments":true,"path":"2021/03/29/js遍历数组/","link":"","permalink":"http://yoursite.com/2021/03/29/js遍历数组/","excerpt":"","text":"JS 遍历数组1.普通for循环123for (i = 0; i &lt; loopTimes; i++) &#123; console.log(i);&#125; 2.弱化for循环123for(j = 0; arr[j]!=null; j++) &#123;&#125; 3.foreach循环方法对数组的每个元素执行一次提供的函数。总是返回undefined 1234567//forEach方法中的function回调有三个参数：//第一个参数是遍历的数组内容，//第二个参数是对应的数组索引，//第三个参数是数组本身,可用this调用head.forEach(function (element, index, arr) &#123; element.checked = true;&#125;); 4.foreach变种document.querySelectorAll()返回的并不是我们想当然的数组(对数组进行解析是html的每个元素节点列表，使用getElementsByTagNames()也是一样)，而是NodeList，对NodeList，它里面没有.forEach方法，我们使用了这样的方法进行循环: 123456789101112//调用数组的原型相关方法Array.prototype.forEach.call(arr,function(el)&#123; &#125;);//简写[].prototype.forEach.call(arr,function(el, index, arr1)&#123; &#125;);//参数//arr 传入的参数NodeList//.call() 用arr替换[]作为传入参数//其余参数和foreach一样 5.for in循环（不建议使用）1).index索引为字符串型数字，不能直接进行几何运算。 2).遍历顺序有可能不是按照实际数组的内部顺序。 3).使用for in会遍历数组所有的可枚举属性，包括原型。 缺点：给数组添加了原型函数，导致循环的结果多了一个函数。将Array数组的原型添加了方法，导致循环的时候将该方法也遍历到了，所以for…in…循环最好使用在遍历对象上，不要用来遍历数组。 123for(var i in arr) &#123;&#125; 6.for of 循环 （可遍历Symbol）https://www.cnblogs.com/wangxiayun/p/10194806.htmlfor…of是ES6新增的遍历方式，它提供了统一的遍历机制。所有实现了[Symbol.iterator]接口的对象都可以被遍历。for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。 优点： 有着同for...in一样的简洁语法，但是没有for...in那些缺点 不同用于forEach方法，它可以与break、continue和return配合使用 提供了遍历所有数据结构的统一操作接口 12345678let j = 0for(var i of this.hasSelectedList) &#123; if(this.hasSelectedList[i] == id) &#123; j = i break; &#125;&#125;this.hasSelectedList.splice(j,1) for…of获取索引 entries返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys返回一个遍历器对象，用来遍历所有的键名。 values返回一个遍历器对象，用来遍历所有的键值。 1234let arr = ['a', 'b', 'c']; for (let pair of arr.entries) &#123; console.log(pair); &#125; // [0, 'a'] // [1, 'b'] // [2, 'c'] 类似数组的对象类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList 对象、arguments对象的例子。 123456789101112131415// 字符串 let str = \"hello\"; for (let s of str) &#123; console.log(s); // h e l l o &#125; // DOM NodeList对象 let paras = document.querySelectorAll(\"p\");for (let p of paras) &#123; p.classList.add(\"test\"); &#125; // arguments对象 function printArgs &#123; for (let x of arguments) &#123; console.log(x); &#125; &#125; printArgs('a', 'b'); // 'a' // 'b' 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 12345678910111213let arrayLike = &#123; length: 2, 0: &apos;a&apos;, 1: &apos;b&apos; &#125;; // 报错for (let x of arrayLike) &#123; console.log(x); &#125; // 正确 for (let x of Array.from(arrayLike)) &#123; console.log(x); // &apos;a&apos; // &apos;b&apos;&#125; 普通的对象对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。 1234567891011let es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\" &#125;; for (let e in es6) &#123; console.log(e); &#125; // edition // committee // standard for (let e of es6) &#123; console.log(e); &#125; // TypeError: es6 is not iterable 解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 12345678let es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\" &#125;;for (var key of Object.keys(es6)) &#123; console.log(key + ': ' + es6[key]); &#125; 7、map调用的数组的每个元素传递给指定的函数，并返回一个数组 12345678910111213141516171819var arr = [1,2,3,4,5,6]var newArr1 = arr.map(x =&gt; x % 2 == 0 ? x % 2 : x)console.log(newArr1) //[1, 0, 3, 0, 5, 0]//map()方法创建了一个新数组，但新数组并不是在遍历完arr后才被赋值的，而是每遍历一次就得到一个值var newArr2 = arr.map(x =&gt; &#123; if (x % 2 == 0) &#123; return x % 2; &#125;&#125;)console.log(newArr2) //[undefined, 0, undefined, 0, undefined, 0]var newArr3 = arr.map(x =&gt; &#123; if (x % 2 == 0) &#123; return x % 2; &#125; return x;&#125;)console.log(newArr3) //[1, 0, 3, 0, 5, 0] 8、filter参考： https://www.jianshu.com/p/494226d9dd2cfilter用于对数组进行过滤。它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意：filter()不会对空数组进行检测、不会改变原始数组 12345678910111213//函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留；//函数的第一个参数 currentValue 也为必须，代表当前元素的值。//函数的第二个参数 index 为数组索引。//函数的第三个参数 arr 为当前数组。Array.filter(function(currentValue, indedx, arr), thisValue)let arr = [1, 2, 3, 4, 5, 6];let newArr = arr.filter(value =&gt; value % 2 == 0);console.log(newArr) //[2, 4, 6]let ar1 = []let newArr1 = arr.filter(value =&gt; value % 2 == 0);console.log(newArr) //[] 9、every123//数组的每一项都满足给定条件则返回truearr = [1, 2, 3, 4];arr.every((item,index,array) =&gt; &#123;return item &gt; 2;&#125;); // false 10、some12//数组中只要有一项满足条件就返回truearr.some((item,index,array) =&gt; &#123;return item &gt; 2;&#125;); //true 11、reduce参考https://www.jianshu.com/p/e375ba1cfc47","categories":[],"tags":[{"name":"js 数组","slug":"js-数组","permalink":"http://yoursite.com/tags/js-数组/"}]},{"title":"页面传参","slug":"页面传参","date":"2021-03-29T01:37:30.000Z","updated":"2021-03-29T01:54:29.097Z","comments":true,"path":"2021/03/29/页面传参/","link":"","permalink":"http://yoursite.com/2021/03/29/页面传参/","excerpt":"","text":"HTML vue 页面跳传参 一、html ——– 通过url， js 参考：https://blog.csdn.net/qq_27628085/article/details/90763963 123456789101112131415161718192021222324252627282930313233343536373839404142//改变当前页面， url 可以拼接参数window.location.href='hello.html'//接收页面传值方法//window.location.search 为 ？及以后的部分function getParams(key) &#123; var reg = new RegExp(\"(^|&amp;)\" + key + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null; &#125;;//第一个参数是要打开的页面的url,第二个参数是窗口目标，第三个参数是一个特定字符串以及一个表示新页面是否取代浏览器历史集中当前加载页面的布尔值，通常只需要传递第一个参数。第二个参数还可以是”_blank”,”_self”,”_parent”,”_top”这样的特殊窗口名称，”_blank”打开新窗口,”_self”实现的效果同window.location.href.window.open(url, string，boolean)//弹窗可能被屏蔽，有两种情况//1.浏览器内置的屏蔽程序阻止弹出窗口，那么 window.open()很可能返回Null，此时，只要监测这个返回的值就可以确定弹出窗口是否被屏蔽var newWin = window.open(url);if(newWin == null)&#123; alert(\"弹窗被阻止\");&#125;//2.浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误，因此，要像准确的检测弹出窗口是否被屏蔽，必须在检测返回值的同时，将window.open()封装在try-catch块中&lt;script&gt; var blocked = false; try&#123; var index = \"lemon\"; var url = \"receive.html?index=\"+index; $(\"#more\").click(function()&#123; var newWin = window.open(url); if(newWin == null)&#123; blocked = true; &#125; &#125;); &#125; catch(ex)&#123; block = true; &#125; if(blocked)&#123; alert(\"弹出窗口被阻止\"); &#125; &lt;/script&gt; 二、通过localStorage 和 sessionStorage 先存本地再取出数据 12345678910111213141516171819//localStorage是持久化的本地保存，只要你找不到其所在地没有主动删掉，就会一直存在。//sessionStorage是会话级别的本地保存，比如一个页面关闭的时候该页面设置的sessionStorage数据会自动消失，在不同浏览器窗口不会共享的，即使是同一个浏览器的同一个页面。当会话结束，sessionstroage保存值也会清空。//用setItem来存数据，第一个参数是 名字，第二个参数是存数的数据//存数据window.localStorage.setItem(“data”, “kevin”);window.sessionStorage.setItem(“data”, “kevin”);//用getItem来取数据，参入要取数据的 名字就好//取数据window.localStorage.getItem(“data”);window.sessionStorage.getItem(“data”);//当然如果要存储的数据是一个对象的话，就需要将对象转换为字符串，在取数据的在将字符串转为对象就可以了//对象转字符串 JSON.stringify( ” 对象 ” )//字符串转对象 JSON.parse( ” 字符串 ” ) 三、通过cookie, 具体可参考参考链接 1234567891011//cookie前端与后台都可以创建保存在客户端,有默认有效时间,当然也可以清除浏览器cookie;//创建方式,cookie键值对以等号方式连接cookie之间用分号分开;var name=\"liuliu\";var age=28;document.cookie=\"name=\"+name;document.cookie=\"age=\"+age;//获取全部cookie字符串:document.cookie; 四、vue 1、params 相当于post请求，页面跳转时参数不会在地址栏中显示 12345678910111213141516171819202122//使用params传参时 刷新页面参数消失this.$router.push(&#123;path: `/describe/$&#123;id&#125;`&#125;)//路由配置&#123; path: '/describe/:id', name: 'Describe', component: Describe&#125;//通过路由属性中的name来确定匹配的路由，通过params来传递参数// 路由正常配置即可// 配置时：添加:/id 也可以不添加，不添加数据会在url后面显示，不添加数据就不会显示this.$router.push(&#123; //params传参 需要使用 name 否则取不到；对应路由配置的 name name: 'Describe', params: &#123; id: id &#125; &#125;)//接收参数this.$route.params.id 2、query 相当于get请求，页面跳转时参数会在地址栏中显示 123456789101112131415161718192021222324//使用path来匹配路由，然后通过query来传递参数；这种情况下 query传递的参数会显示在url后面?id=？this.$router.push(&#123; path: '/describe', query: &#123; id: id &#125; &#125;)//子组件接收参数： this.$route.query.id/* 参数获取，params和query区别，query参数在地址栏显示，params的参数不在地址栏显示*///和push的区别，push有记录一个history，replace没有this.$router.replace(&#123;name: '/detail', params: &#123;id: e&#125;&#125;)//resolve页面跳转可用新页面打开//2.1.0版本后，使用路由对象的resolve方法解析路由，可以得到location、router、href等目标路由的信息。得到href就可以使用window.open开新窗口了（这边应用：https://segmentfault.com/q/1010000009557100下的一个回答）const new = this.$router.resolve(&#123;name: '/detail', params: &#123;id: e&#125;&#125;)window.open(new.href,'_blank')window.opener() //获取父窗口对象，没有则为null 3.、修改路由的query参数 12345678910111213141516//安装 webpack-mergenpm i webpack-merge//导入 webpack-mergeimport merge from 'webpack-merge';//修改原有参数this.$router.push(&#123; query:merge(this.$route.query,&#123;'auditedDeptId':this.ruleForm.auditedDeptId&#125;)&#125;)//新增一个参数this.$router.push(&#123; query:merge(this.$route.query,&#123;'newParams':'new'&#125;)&#125;)//替换所有参数 this.$router.push(&#123; query:merge(&#123;&#125;,&#123;'maxPrice':'630'&#125;)&#125;)","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"ts使用","slug":"ts使用","date":"2021-03-26T08:33:51.000Z","updated":"2021-03-29T07:36:13.694Z","comments":true,"path":"2021/03/26/ts使用/","link":"","permalink":"http://yoursite.com/2021/03/26/ts使用/","excerpt":"一、基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用123//变量//一开始赋值什么类型就只能使用什么类型let xx:类型 = yy;","text":"一、基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用123//变量//一开始赋值什么类型就只能使用什么类型let xx:类型 = yy; 1、布尔型123//布尔类型let flag:boolean = trueconsole.log(flag); 2、数字类型12345678910//数字类型let a1: number = 10 // 十进制let a2: number = 0b1010 // 二进制let a3: number = 0o12 // 八进制let a4: number = 0xa // 十六进制console.log(a1); //10console.log(a2); //10console.log(a3); //10console.log(a4); //10 3、字符串类型1234//字符串类型let str:string = 'zs'console.log(str); //zsconsole.log(str + a1); // zs10 4、 undefined 和 null12345678910// undefined 和 null 都可以作为其他类型的子类型let u: undefined = undefinedlet n: null = nullconsole.log(u); //undefinedconsole.log(n); //null//在严格模式下会报错//在 tsconfig.json 下设置 \"strict\": false, let num:number = undefinedconsole.log(num); //undefined 5、数组typeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组123let list1: number[] = [1, 2, 3] //数组定义后里面的数据类型就固定了//泛型let list2: Array&lt;number&gt; = [1, 2, 3] 6、元组(Tuple)1234//定义数组时，类型和数组的个数一开始就确定了let list3:[string, number, boolean] = ['zs', 12, false]console.log(list3); //['zs', 12, false]// console.log(list3[1].startsWith(12)); 直接报错 7、枚举类型123456789101112131415161718192021222324252627282930313233343536373839404142//enum 类型是对 JavaScript 标准数据类型的一个补充//枚举里面的每个数据都可以称为元素，有从0开始的编号enum Color &#123; Red, Green, Blue &#125;// 枚举数值默认从0开始依次递增// 根据特定的名称得到对应的枚举数值let myColor: Color = Color.Green // 0console.log(myColor, Color.Red, Color.Blue) // 1 0 2//可以手动改变值//全部手动赋值enum Color1 &#123; Red = 10, Green = 100, Blue = 50 &#125;console.log(Color1，Color1.Red, Color1.Green, Color1.Blue) // &#123;10: \"Red\", 50: \"Blue\", 100: \"Green\", Red: 10, Green: 100, Blue: 50&#125; 10 100 50//手动赋值第一二个enum Color1 &#123; Red = 100, Green = 50, Blue &#125;console.log(Color1，Color1.Red, Color1.Green, Color1.Blue) //&#123;50: \"Green\", 51: \"Blue\", 100: \"Red\", Red: 100, Green: 50, Blue: 51&#125; 100 50 51//手动赋值第一二个enum Color1 &#123; Red = 51, Green = 50, Blue &#125;console.log(Color1，Color1.Red, Color1.Green, Color1.Blue) //&#123;50: \"Green\", 51: \"Blue\", Red: 51, Green: 50, Blue: 51&#125; 51 50 51console.log(Color1[2]); //undefinedconsole.log(Color1[51]); //Blue 8、any (anyScript)12let list: any[] = [1, true, 'free']list[1] = 100 9、void123456789101112131415//某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void；总是返回undefinedfunction noReturn(a:string):void &#123; return undefined&#125;console.log(noReturn('aaa')) //undefinedfunction noReturn(a:string):void &#123; return null&#125;console.log(noReturn('aaa')) //null//以下编译不通过function noReturn(a:string):void &#123; return a&#125; 10、objectobject 表示非原始类型，也就是除 number，string，boolean之外的类型。 123456789function fn2(obj:object):object &#123; console.log('fn2()', obj) return &#123;&#125; // return undefined // return null&#125;console.log(fn2(new String('abc')))// console.log(fn2('abc') // errorconsole.log(fn2(String)) 11、联合类型123function fn(x: number | string) &#123; return x.toString()&#125; 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 1234567891011121314151617/* 类型断言(Type Assertion): 可以用来手动指定一个值的类型语法: 方式一: &lt;类型&gt;值 方式二: 值 as 类型 tsx中只能用这种方式*//* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */function getLength(x: number | string) &#123; if ((&lt;string&gt;x).length) &#123; // return (&lt;string&gt;x).length return (x as string).length &#125; else &#123; return x.toString().length &#125;&#125;console.log(getLength('abcd'), getLength(1234)) // 4,4 类型推断TS会在没有明确的指定类型的时候推测出一个类型 12345678910/* 定义变量时赋值了, 推断为对应的类型 */let x = 123 // number// x = 'abc' // error/* 定义变量时没有赋值, 推断为any类型 */let y // any类型console.log(y) //undefinedconsole.log(typeof y) //undefinedy = 123y = 'abc'","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"ts","slug":"ts","date":"2021-03-26T06:20:54.000Z","updated":"2021-03-27T13:30:50.104Z","comments":true,"path":"2021/03/26/ts/","link":"","permalink":"http://yoursite.com/2021/03/26/ts/","excerpt":"初步认识引用：https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html一、初始1.ts文件直接写js代码，在html代码中可以直接使用（我自己实验不行，必须进行编译）2.ts函数形参使用类型修饰符，在编译后不会出现3.ts使用 let 进行修饰，编译后变成 var","text":"初步认识引用：https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html一、初始1.ts文件直接写js代码，在html代码中可以直接使用（我自己实验不行，必须进行编译）2.ts函数形参使用类型修饰符，在编译后不会出现3.ts使用 let 进行修饰，编译后变成 var 二、自动编译12345671). 生成配置文件tsconfig.json tsc --init2). 修改tsconfig.json配置 \"outDir\": \"./js\", //生成在js目录下 \"strict\": false, 3). 启动监视任务: 终端 -&gt; 运行任务 -&gt; 监视tsconfig.json 三、类型注解TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。可以编译但是会警告你代码可能不会按预期执行。四、webpack打包ts1、入口JS: src/main.ts2、index页面: public/index.html3、webpack配置文件build/webpack.config.js4、下载依赖12345npm install -D typescriptnpm install -D webpack@4.41.5 webpack-cli@3.3.10 webpack-dev-server@3.10.2npm install -D html-webpack-plugin clean-webpack-pluginnpm install -D ts-loadernpm install -D cross-env 5、配置打包命令12345678910//\"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js\",//\"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\"//package.json 下\"scripts\": &#123; \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js\", \"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, 6、运行与打包12npm run devnpm run build 报错解决12345Cannot read property 'tap' of undefined at webpack (F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack\\lib\\webpack.js:51:13) at startDevServer (F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js:94:16) at F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js:166:3 at F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack-dev-server\\lib\\utils\\processOptions.js:33:9 1234567891011//原因：webpack版本 html-webpack-plugin版本不匹配//解决：先降级html-webpack-plugin 至4.0.0npm uninstall html-webpack-plugin -Dnpm install html-webpack-plugin@4.0.0 -D//仍不解决，可能是webpack全局版本覆盖了局部版本//重新安装webpack 和webpack-clinpm uninstall webpack webpack-cli -gnpm install webpack@4.41.5 webpack-cli@3.3.10 -g//在局部安装npm install webpack@4.41.5 webpack-cli@3.3.10 -D","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]}],"categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"js 数组","slug":"js-数组","permalink":"http://yoursite.com/tags/js-数组/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]}