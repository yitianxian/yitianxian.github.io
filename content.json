{"meta":{"title":"记录","subtitle":"千里之行，始于足下","description":null,"author":"Z-Q-K","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2021-03-28T08:43:33.000Z","updated":"2021-03-28T08:46:27.089Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-03-28T08:47:05.000Z","updated":"2021-03-28T08:47:23.285Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"css-img踩坑","slug":"css-img踩坑","date":"2021-04-28T11:58:21.000Z","updated":"2021-04-28T12:14:08.330Z","comments":true,"path":"2021/04/28/css-img踩坑/","link":"","permalink":"http://yoursite.com/2021/04/28/css-img踩坑/","excerpt":"","text":"先上代码: 123456&lt;div class=\"nav-set-item\"&gt; &lt;span&gt;文章&lt;/span&gt; &lt;img class=\"img-down\" src=\"skin/images/descending-order.png\"/&gt; &lt;img class=\"img-up\" src=\"skin/images/cannot-Ascending-order-.png\"/&gt; &lt;img class=\"img-del\" src=\"skin/images/dele.png\"/&gt;&lt;/div&gt; 123.nav-set-item img:first-child &#123; position: absulate;&#125; 这一段css无论如何都不能生效 后来问大佬,原来css中处理img并不是当成img,css将span也当作img处理,所以这样是选中的是第一个span 解决方式::从第二个元素开始 1234.nav-set-item img:nth-child(2) &#123; left: 721px; top:13px;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"reactRouter","slug":"reactRouter","date":"2021-04-28T11:23:20.000Z","updated":"2021-04-28T12:14:22.875Z","comments":true,"path":"2021/04/28/reactRouter/","link":"","permalink":"http://yoursite.com/2021/04/28/reactRouter/","excerpt":"","text":"安装1npm i --save react-router-dom 初级使用路由模式同样有两种 hash（HashRouter） 和 history(BrowserRouter) 123456789101112131415//index.js中包裹Appimport &#123;BrowserRouter&#125; from 'react-router-dom'ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById('root'));//导航区&lt;Link classname='list-group-item' to=\"/about\"&gt;About&lt;/Link&gt;&lt;Link classname='list-group-item' to=\"/home\"&gt;Home&lt;/Link&gt;//展示区&lt;Route path='/home' compoent=&#123;Home&#125;&gt;&lt;/Route&gt;&lt;Route path='/about' compoent=&#123;About&#125;&gt;&lt;/Route&gt;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react组件间传递参数","slug":"react/react组件间传递参数","date":"2021-04-25T03:40:12.000Z","updated":"2021-04-25T12:43:14.914Z","comments":true,"path":"2021/04/25/react/react组件间传递参数/","link":"","permalink":"http://yoursite.com/2021/04/25/react/react组件间传递参数/","excerpt":"","text":"父传子 props与vue一样 ：组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props** 正常情况下 props 的拥有权不属于当前组件，是别人传给你的，你用的时候用 props 来引用，所以修改的权限应该由上面来决定 父组件传值： 1234567891011121314151617181920212223state = &#123; todos: [ &#123;id: '001', name: '吃饭', done: true&#125;, &#123;id: '002', name: '睡觉', done: false&#125;, &#123;id: '003', name: '打游戏', done: true&#125;, ], list: &#123; 'id': '002', name:'zs' &#125; &#125;addToDo = (value) =&gt; &#123; const&#123;todos&#125; = this.state const newTOdos = [todoObj, ...todos] this.setState(&#123;todos: newTOdos&#125;)&#125;//render 中const &#123;todos&#125; = this.state//对象可以直接结构传递&lt;List todos=&#123;todos&#125; &#123;...list&#125; &#123;...list2&#125;&gt;&lt;/List&gt;//传递一个函数&lt;Header addToDo=&#123;this.addToDo&#125;&gt;&lt;/Header&gt; 子组件接收并传值： 12345678910111213141516171819//render中//如果解构后有相同的属性,后面的解构会覆盖前面的const &#123;todos, id&#125; = this.propsconsole.log(id); // 003//子组件向父组件传值handleKeyUp = (event)=&gt; &#123; const &#123;keyCode, target&#125; = event if(target.value.trim() !== '' &amp;&amp; keyCode === 13 ) &#123; console.log(target.value); let params = &#123; id: nanoid(), name:target.value, done:false &#125; this.props.addToDo(params) target.value = '' &#125;&#125; 兄弟组件传值(消息订阅与发布)：1234567891011121314151617181920212223npm i pubsub-js//订阅消息,组件一挂载就发布, 返回一个订阅token//第一个参数: 订阅名//第二个参数: 回调//回调函数的第一个参数: 订阅名//回调函数的第二个参数: 订阅传过来的值componentDidMount() &#123; this.token = PubSub.subscribe('at', (_, data) =&gt; &#123; this.setState(data) &#125;)&#125;//订阅的值发生变动,调用//第一个参数: 订阅名//第二个参数: 传递的值PubSub.publish('at', &#123;'name':'tom'&#125;)//组件销毁前要删除tokencomponentWillUnmount() &#123; PubSub.unsubscribe(this.token)&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react生命周期","slug":"react/react生命周期","date":"2021-04-23T05:31:53.000Z","updated":"2021-04-23T08:46:20.613Z","comments":true,"path":"2021/04/23/react/react生命周期/","link":"","permalink":"http://yoursite.com/2021/04/23/react/react生命周期/","excerpt":"","text":"旧生命周期react旧生命周期.png) vue 旧生命周期 react新生命周期.png) 使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*以下三个与之前相比需加上 UNSAVE_ 前缀*/UNSAVE_componentWillMount() &#123; console.log('Demo-componentWillMount');&#125;UNSAVE_componentWillUnmount() &#123; console.log('Demo-componentWillUnmount');&#125;UNSAVE_componentWillReceiveProps(props) &#123; console.log(props); console.log('DemoChild2-componentWillReciveProps');&#125;/*新增两个生命周期*///报错 getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.//不能这样用getDerivedStateFromProps() &#123; console.log('Demo-getDeivedPropForms');&#125;//应该这样用//需要返回一个状态对象或者null//可以接收propsstatic getDerivedStateFromProps(props) &#123; console.log('Demo-getDeivedPropForms'); return null&#125;//更新之前获取快照 返回值作为参数返回给 componentDidUpdate, 可以用来传递参数getSnapshotBeforeUpdate() &#123; console.log('Demo-getSnpshotBeforeUpdate'); return null&#125;//preProps props//preState state//snapshot getSnapshotBeforeUpdate返回值componentDidUpdate(preProps, preState, snapshot) &#123; console.log(preProps, preState, snapshot); console.log('Demo-componentDidUpdate');&#125;/*弃用一个*/componentWillUpdate() &#123; &#125;","categories":[],"tags":[{"name":"reactreact旧生命周期","slug":"reactreact旧生命周期","permalink":"http://yoursite.com/tags/reactreact旧生命周期/"}]},{"title":"js函数柯里化","slug":"js/js函数柯里化","date":"2021-04-23T02:42:25.000Z","updated":"2021-04-23T03:16:05.201Z","comments":true,"path":"2021/04/23/js/js函数柯里化/","link":"","permalink":"http://yoursite.com/2021/04/23/js/js函数柯里化/","excerpt":"","text":"函数柯里化函数调用继续返回函数，实现多次接收参数最后统一处理只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数简单的柯里化函数： 123456789function sum(a) &#123; return (b) =&gt; &#123; return (c) =&gt; &#123; return a + b + c &#125; &#125;&#125;console.log(sum(1)(2)(3)); //6 应用： react中： 12345678910111213141516saveFormData = (dataType) =&gt; &#123; return (event) =&gt; &#123; this.setState(&#123;[dataType]: event.target.value&#125;) &#125; &#125;//react 默认传递参数event 即实际调用为 this.saveFormData('username')（event）//onChange 需要函数作为调用，saveFormData('username') 返回的是一个函数render() &#123; return ( &lt;input type='text' name='username' onChange=&#123;this.saveFormData('username')&#125;&gt; &lt;/input&gt; )&#125; 数组排序 12345678910111213141516171819202122232425262728293031323334353637383940/*** @function 指定数组排序规则* @param str &#123;string?&#125; 单个属性，不确定个数* @param num &#123;Number?&#125; 是否升序 默认降序* @version 1.0.0* @description 针对特殊业务需求，用于图表的排序*/sortBy() &#123; let num = 1 let arr = [] //最后一个参数是数字 if(typeof arguments[arguments.length - 1] === 'number' &amp;&amp; !isNaN(arguments[arguments.length - 1])) &#123; //获取最后一个参数的值 num = arguments[arguments.length - 1] ? 1 : -1 arr = arguments.slice(0, arguments.length - 1) &#125;else &#123;//最后一个参数不是数字 arr = arguments &#125; // num = num ? 1 : -1 return function(a,b)&#123; // 获取其他参数的值 let a1 = 0 let b1 = 0 //这里 a[arr[i]] 后端返回的值确定是number for(var i = 0, len = arr.length; i &lt; len; i++) &#123; a1 += a[arr[i]] b1 += b[arr[i]] &#125; if(a1 &gt; b1)&#123; return num * -1; &#125; if(a1 &lt; b1)&#123; return num * 1; &#125; return 0; &#125;&#125;//使用data.sort(this.sortBy('isLeader', 'isNotLeader'))","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"scss中deep","slug":"css/scss中deep","date":"2021-04-20T02:29:18.000Z","updated":"2021-04-20T02:44:20.362Z","comments":true,"path":"2021/04/20/css/scss中deep/","link":"","permalink":"http://yoursite.com/2021/04/20/css/scss中deep/","excerpt":"","text":"vue中有的组件是挂载到全局，查看时与app同级，这时的组件样式更改不能在vue文件中的scope中更改，因为无法读取到。 同时使用deep有三种运算符 123456789&gt;&gt;&gt; =&gt; 如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符： 有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作/deep/ =&gt; 在scss中有时不能正确编译::v-deep =&gt; 与/deep/用法一致，听说比/deep/快 ::v-deep .MySteps &#123; width: 50% !important; &#125;","categories":[],"tags":[{"name":"scss","slug":"scss","permalink":"http://yoursite.com/tags/scss/"}]},{"title":"vue3踩坑记录","slug":"vue3/vue3踩坑记录","date":"2021-04-19T11:03:16.000Z","updated":"2021-04-20T03:51:02.436Z","comments":true,"path":"2021/04/19/vue3/vue3踩坑记录/","link":"","permalink":"http://yoursite.com/2021/04/19/vue3/vue3踩坑记录/","excerpt":"","text":"报错：Error: [vue-composition-api] must call Vue.use(VueCompositionAPI) before using any function.原因：composition-api 需要安装并引入使用解决：123npm install @vue/composition-api --saveimport VueCompositionApi from '@vue/composition-api'Vue.use(VueCompositionApi) 报错：TypeError: Cannot read property ‘util’ of undefined原因：import { defineComponent } from ‘@vue/composition-api’， 这是2.0-3.0的过度版本的脚手架创建的解决：升级vue-cli至最新版本123npm uninstall vue-cli -gnpm i @vue/cli -gvue --version 获取 ctx （vue2中的this对象 ）123import &#123; getCurrentInstance&#125; from 'vue';const &#123; ctx &#125;:any = getCurrentInstance() 此时会报错 Property ‘ctx’ does not exist on type ‘ComponentInternalInstance’.此时使用： 12345// @ts-ignoreconst &#123; ctx &#125;:any = getCurrentInstance()//并关闭ts严格模式\"strict\": false, 会报错：Do not use “@ts-ignore” because it alters compilation errors @typescript-eslint/ban-ts-comment123//这是eslint语法检查报错//可以将 vue.config.js 中的 lintOnSave: false 注释掉//lintOnSave: false, 终极方案:anyScript1234const &#123; ctx &#125;:any = getCurrentInstance()//注意 以下是不行的,因为eslint语法会覆盖ts语法,以下为eslint重命名语法const &#123; ctx:any &#125;= getCurrentInstance()","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://yoursite.com/tags/vue3/"}]},{"title":"vue3路由","slug":"vue3/vue3路由","date":"2021-04-17T09:45:39.000Z","updated":"2021-04-17T12:40:14.058Z","comments":true,"path":"2021/04/17/vue3/vue3路由/","link":"","permalink":"http://yoursite.com/2021/04/17/vue3/vue3路由/","excerpt":"","text":"路由配置跟着公司大佬学习3.0前端路由配置 在定义文件时不要使用router后缀否则会无法加载router-view 入口文件 index.ts123456789101112131415161718192021222324252627282930//import &#123; createRouter, createWebHistory, RouteRecordRaw &#125; from 'vue-router'import &#123; staticRouters &#125; from './staticRouters';import defaultRouters from './defaultRouters';const routes: any = staticRouters.concat(defaultRouters);const router = createRouter(&#123; history: createWebHistory(process.env.BASE_URL), routes&#125;)router.beforeEach((to, from, next) =&gt; &#123; // let userInfo = localStorage.getItem('user'); const userInfo = \"xxxxxxx\"; if (to.path === \"/login\") &#123; next(); &#125; else &#123; if (userInfo) &#123; next(); &#125; else &#123; next(&#123; path: '/login' &#125;); &#125; &#125;&#125;);export default router","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://yoursite.com/tags/vue3/"}]},{"title":"vue-el限制输入","slug":"elementUI/vue-el限制输入","date":"2021-04-13T06:26:35.000Z","updated":"2021-04-13T06:29:53.212Z","comments":true,"path":"2021/04/13/elementUI/vue-el限制输入/","link":"","permalink":"http://yoursite.com/2021/04/13/elementUI/vue-el限制输入/","excerpt":"","text":"oninput限制输入12345&lt;el-input v-model='num' oninput=\"if(/^[0-9]*$/.test(value) == false) &#123; value = null &#125; if(value &lt; 0)&#123;value=0&#125; if(value &gt; 100)&#123;value=100&#125; if(value&gt; 0 &amp;&amp; value &lt; 100) &#123;value=value.replace(/[^\\d]/g,'')&#125;\" &gt;&lt;/el-input&gt;","categories":[],"tags":[{"name":"vue-el踩坑","slug":"vue-el踩坑","permalink":"http://yoursite.com/tags/vue-el踩坑/"}]},{"title":"vue路由模式","slug":"elementUI/vue路由模式","date":"2021-04-08T09:39:47.000Z","updated":"2021-04-08T10:12:39.977Z","comments":true,"path":"2021/04/08/elementUI/vue路由模式/","link":"","permalink":"http://yoursite.com/2021/04/08/elementUI/vue路由模式/","excerpt":"","text":"路由模式今天使用路由跳转时始终访问不到指定页面 12345const href = `/informationAudit/intoInfoAudit?id=` + id;window.open(href, \"_blank\");//点击后路由跳转/informationAudit/intoInfoAudit?id=undefined#/dashboard 后来发现路由模式不对 123456789const createRouter = () =&gt; new Router(&#123; //不应该注释 //mode: 'history', // 路由模式 scrollBehavior: () =&gt; (&#123; y: 0 &#125;), isAdd: false, //是否已经添加动态(菜单)路由 routes: constantRoutes, base: '/icostviews/' &#125;); vue-router有两种模式： hash（默认）： 1、使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载 2、url带有# 3、前端路由修改的是#中的信息 12//如果直接输入页面会跳转/informationAudit/intoInfoAudit?id=undefined#/supplierManagement/informationAudit history： 1、这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 2、使用history 模式时，URL 就像正常的 url 3、需要后台配置支持，刷新会请求服务器","categories":[],"tags":[{"name":"vue-Router","slug":"vue-Router","permalink":"http://yoursite.com/tags/vue-Router/"}]},{"title":"js正则","slug":"js/js正则","date":"2021-04-07T08:00:57.000Z","updated":"2021-04-07T08:07:54.509Z","comments":true,"path":"2021/04/07/js/js正则/","link":"","permalink":"http://yoursite.com/2021/04/07/js/js正则/","excerpt":"","text":"正则常用元字符串 元字符 说明 \\d 匹配数字 \\D 匹配任意非数字的字符 \\w 匹配字母或数字或下划线 \\W 匹配任意不是字母，数字，下划线 \\s 匹配任意的空白符 \\S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\\u4e00-\\u9fa5] 匹配汉字 注意事项123456789101112131415161718//提取邮件中的每一部分var str = 'xxxx@itcast.com';var reg = /(\\w+)@(\\w+)\\.(\\w+)/;console.log(RegExp); //RegExp() &#123; [native code] &#125;console.log(RegExp.$1); //xxxxconsole.log(RegExp.$2); //itcastconsole.log(RegExp.$3); //com//为什么 RegExp.$1 有值//参考：https://blog.csdn.net/qq_42423964/article/details/102385983RegExp 是javascript中的一个内置对象。为正则表达式。RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个 子匹配(以括号为标志)字符串，以此类推，RegExp.$2，RegExp.$3，..RegExp.$99总共可以有99个匹配如果你直接在控制台打印RegExp, 出现的一定是一个空字符串: \"\"。那么, 我们在什么时候可以使用RegExp.$1呢?//其实RegExp这个对象会在我们调用了正则表达式的方法后, 自动将最近一次的结果保存在里面, 所以如果我们在使用正则表达式时, 有用到分组, 那么就可以直接在调用完以后直接使用RegExp.$xx来使用捕获到的分组内容","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js对象方法","slug":"js/js对象方法","date":"2021-04-07T07:41:27.000Z","updated":"2021-04-07T07:42:00.717Z","comments":true,"path":"2021/04/07/js/js对象方法/","link":"","permalink":"http://yoursite.com/2021/04/07/js/js对象方法/","excerpt":"","text":"对象深拷贝1234567891011121314151617181920212223// 深拷贝 把o1的成员拷贝给o2function deepCopy(o1, o2) &#123; for (var key in o1) &#123; // 获取key属性对应的值 var item = o1[key]; // 如果item 是对象？ // var o = &#123;&#125; if (item instanceof Object) &#123; // var o = &#123;&#125;; o2[key] = &#123;&#125;; deepCopy(item, o2[key]); &#125; else if (item instanceof Array) &#123; // 如果item 是数组呢？ // var arr = []; o2[key] = []; deepCopy(item, o2[key]); &#125; else &#123; // 如果是简单类型 o2[key] = o1[key]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"el-table自定义排序","slug":"elementUI/el-table自定义排序","date":"2021-04-06T02:38:57.000Z","updated":"2021-04-06T03:12:24.493Z","comments":true,"path":"2021/04/06/elementUI/el-table自定义排序/","link":"","permalink":"http://yoursite.com/2021/04/06/elementUI/el-table自定义排序/","excerpt":"","text":"表格自定义排序12345678910111213&lt;el-table ref=\"tableCot\" :data=\"tableData\" :default-sort = \"&#123;prop: 'projectNo', order: 'descending'&#125;\"&gt; &lt;el-table-column align=\"center\" :show-overflow-tooltip=\"true\" prop=\"projectNo\" label=\"项目编号\" :sortable=\"true\" :sort-method=\"sortby\"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; 123456//可以先看看a，b的内容sortby(a, b) &#123; let x = parseInt(a.projectNo.substring(19)) let y = parseInt(b.projectNo.substring(19)) return x &gt; y ? -1 : 1&#125;,","categories":[],"tags":[{"name":"Element UI","slug":"Element-UI","permalink":"http://yoursite.com/tags/Element-UI/"}]},{"title":"vue3新特性-使用","slug":"vue3/vue3新特性-使用","date":"2021-03-31T09:32:34.000Z","updated":"2021-04-01T14:25:12.871Z","comments":true,"path":"2021/03/31/vue3/vue3新特性-使用/","link":"","permalink":"http://yoursite.com/2021/03/31/vue3/vue3新特性-使用/","excerpt":"","text":"setup 新的option, 所有的组合API函数都在此使用, 只在初始化时执行一次 函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用 123456789101112//理解：将2.0中data 和 methods 统一,必须通过 return 返回才可以使用import &#123;defineComponent&#125; from 'vue';//暴露一个定义好的组件export default defineComponent(&#123; name: 'App', setup() &#123; return &#123; &#125; &#125;&#125;); ref 作用: 定义一个数据的响应式 语法: const xxx = ref(initValue): 创建一个包含响应式数据的引用(reference)对象 js中操作数据: xxx.value 模板中操作数据: 不需要.value 一般用来定义一个基本类型的响应式数据 12&lt;h3&gt;&#123;&#123; count &#125;&#125;&lt;/h3&gt;&lt;button @click=\"updateCount\"&gt;更新数据&lt;/button&gt; 123456789101112131415161718192021222324252627import &#123;defineComponent, ref&#125; from 'vue';setup()&#123; // console.log('第一次') // 变量 // let count = 0 // 此时的数据并不是响应式的数据(响应式数据:数据变化,页面跟着渲染变化) // ref是一个函数,作用:定义一个响应式的数据,返回的是一个Ref对象,对象中有一个value属性,如果需要对数据进行操作,需要使用该Ref对象调用value属性的方式进行数据的操作 // html模版中是不需要使用.value属性的写法 // 一般用来定义一个基本类型的响应式数据 // count 的类型 Ref类型 //count.value = 0 const count = ref(0) console.log(count) // 方法 function updateCount()&#123; console.log('=====') // 报错的原因:count是一个Ref对象,对象是不能进行++的操作 // count++ count.value++ &#125; // 返回的是一个对象 return &#123; // 属性 count, // 方法 updateCount &#125;&#125; reactive 作用: 定义多个数据的响应式 const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象 响应式转换是“深层的”：会影响对象内部所有嵌套的属性 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的 123456789101112131415161718192021//目标对象const obj = &#123; name: '小明', age: 20, wife: &#123; name: '小甜甜', age: 18, cars: ['奔驰', '宝马', '奥迪'], &#125;, &#125;//代理对象const user = reactive&lt;any&gt;(obj)const updateUser = () =&gt; &#123; // 直接使用目标对象的方式来更新目标对象中的成员的值,是不可能的,只能使用代理对象的方式来更新数据(响应式数据) // obj.name += '===' // 通过当前的代理对象把目标对象中的某个数组属性添加一个新的属性 user.name += '==='&#125;// 总结: 如果操作代理对象,目标对象中的数据也会随之变化,同时如果想要在操作数据的时候,界面也要跟着重新更新渲染,那么也是操作代理对象//操作目标对象,目标对象中的数据会随之变化,但不会重新渲染 computed 和 watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//computed 和 watch 也放入setup之中import &#123; defineComponent, reactive, computed, watch, ref, watchEffect,&#125; from 'vue'export default defineComponent(&#123; name: 'App', setup() &#123; // 定义一个响应式对象 const user = reactive(&#123; // 姓氏 firstName: '东方', // 名字 lastName: '不败', &#125;) // 通过计算属性的方式,实现第一个姓名的显示 // vue3中的计算属性 // 计算属性的函数中如果只传入一个回调函数,表示的是get // 第一个姓名: // 返回的是一个Ref类型的对象 const fullName1 = computed(() =&gt; &#123; return user.firstName + '_' + user.lastName &#125;) // 第二个姓名: const fullName2 = computed(&#123; get() &#123; return user.firstName + '_' + user.lastName &#125;, set(val: string) &#123; // console.log('=====',val) const names = val.split('_') user.firstName = names[0] user.lastName = names[1] &#125;, &#125;) // 第三个姓名: const fullName3 = ref('') // 监视----监视指定的数据 watch( user, (&#123; firstName, lastName &#125;) =&gt; &#123; fullName3.value = firstName + '_' + lastName &#125;, &#123; immediate: true, deep: true &#125; ) // immediate 默认会执行一次watch,deep 深度监视 // 监视,不需要配置immediate,本身默认就会进行监视,(默认执行一次) // watchEffect(() =&gt; &#123; // fullName3.value = user.firstName + '_' + user.lastName // &#125;) // 监视fullName3的数据,改变firstName和lastName watchEffect(() =&gt; &#123; const names = fullName3.value.split('_') user.firstName = names[0] user.lastName = names[1] &#125;) // watch---可以监视多个数据的 // watch([user.firstName,user.lastName,fullName3],()=&gt;&#123; // // 这里的代码就没有执行,fullName3是响应式的数据,但是,user.firstName,user.lastName不是响应式的数据 // console.log('====') // &#125;) // 当我们使用watch监视非响应式的数据的时候,代码需要改一下 watch([()=&gt;user.firstName, ()=&gt;user.lastName,fullName3], () =&gt; &#123; // 这里的代码就没有执行,fullName3是响应式的数据,但是,user.firstName,user.lastName不是响应式的数据 console.log('====') &#125;) return &#123; user, fullName1, fullName2, fullName3, &#125; &#125;,&#125;) 生命周期3.0中的生命周期都变成了组合api 3.0中的执行都比2.0中的快 123456789beforeCreate -&gt; 使用 setup()created -&gt; 使用 setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountederrorCaptured -&gt; onErrorCaptured","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://yoursite.com/tags/Vue3/"}]},{"title":"vue3项目创建","slug":"vue3/vue3项目创建","date":"2021-03-30T06:00:49.000Z","updated":"2021-03-30T06:06:45.652Z","comments":true,"path":"2021/03/30/vue3/vue3项目创建/","link":"","permalink":"http://yoursite.com/2021/03/30/vue3/vue3项目创建/","excerpt":"","text":"参考：https://24kcs.github.io/vue3_study/chapter3/02_%E5%88%9B%E5%BB%BAvue3%E9%A1%B9%E7%9B%AE.html#_1-%E4%BD%BF%E7%94%A8-vue-cli-%E5%88%9B%E5%BB%BA","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://yoursite.com/tags/Vue3/"}]},{"title":"ts声明文件和内置对象","slug":"TypeScript/ts声明文件和内置对象","date":"2021-03-30T01:51:51.000Z","updated":"2021-03-30T06:00:04.960Z","comments":true,"path":"2021/03/30/TypeScript/ts声明文件和内置对象/","link":"","permalink":"http://yoursite.com/2021/03/30/TypeScript/ts声明文件和内置对象/","excerpt":"","text":"声明文件当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能 12345678910/* 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。声明语句: 如果需要ts对新的语法进行检查, 需要要加载了对应的类型说明代码 declare var jQuery: (selector: string) =&gt; any;声明文件: 把声明语句放到一个单独的文件（jQuery.d.ts）中, ts会自动解析到项目中所有声明文件下载声明文件: npm install @types/jquery --save-dev 直接安装声明文件*/jQuery('#foo');// ERROR: Cannot find name 'jQuery'. 一般声明文件都会单独写成一个 xxx.d.ts 文件， TS编译器会扫描并加载项目中所有的TS声明文件 很多的第三方库都定义了对应的声明文件库, 库文件名一般为 @types/xxx, 可以在 https://www.npmjs.com/package/package 进行搜索，下载完后可不用手动声明 内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。 123456789101112131415161718//ECMAScript 的内置对象/* 1. ECMAScript 的内置对象 */let b: Boolean = new Boolean(1)let n: Number = new Number(true)let s: String = new String('abc')let d: Date = new Date()let r: RegExp = /^1/let e: Error = new Error('error message')b = true// let bb: boolean = new Boolean(2) // error//BOM 和 DOM 的内置对象const div: HTMLElement = document.getElementById('test')const divs: NodeList = document.querySelectorAll('div')document.addEventListener('click', (event: MouseEvent) =&gt; &#123; console.dir(event.target)&#125;)const fragment: DocumentFragment = document.createDocumentFragment()","categories":[],"tags":[{"name":"Ty","slug":"Ty","permalink":"http://yoursite.com/tags/Ty/"}]},{"title":"ts泛型","slug":"TypeScript/ts泛型","date":"2021-03-29T14:25:11.000Z","updated":"2021-03-30T01:53:15.073Z","comments":true,"path":"2021/03/29/TypeScript/ts泛型/","link":"","permalink":"http://yoursite.com/2021/03/29/TypeScript/ts泛型/","excerpt":"","text":"ts泛型指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。 1234567891011121314151617181920//主要是定义方法时参数类型不确定，使用时参数类型确定，并可以进行参数检查与提示(() =&gt; &#123; // 根据指定的数量 count 和数据 value , 创建一个包含 count 个 value 的数组 function getArr&lt;T&gt;(value: T, count: number): T[] &#123; const arr: Array&lt;T&gt; = [] for(var i = 0; i &lt; count; i++) &#123; arr.push(value) &#125; return arr &#125; const arr1 =getArr&lt;string&gt;(\"str\", 3) console.log(arr1) //[\"str\", \"str\", \"str\"] //多个泛型 function getMsg&lt;K, T&gt;(value1: K, value2: T) &#123; return [value1, value2] &#125; const arr2 = getMsg&lt;number , string&gt;(1, \"zs\") console.log(arr2) //[1, \"zs\"]&#125;)() 泛型接口在定义接口时, 为接口中的属性或方法定义泛型类型在使用接口时, 再指定具体的泛型类型 123456789101112131415161718192021222324252627282930313233343536373839(() =&gt; &#123; interface IbaseCRUD &lt;T&gt; &#123; data: T[] add: (t: T) =&gt; void getById: (id: number) =&gt; T &#125; class User &#123; id?: number; //id主键自增 name: string; //姓名 age: number; //年龄 constructor (name, age) &#123; this.name = name this.age = age &#125; &#125; class UserCRUD implements IbaseCRUD &lt;User&gt; &#123; data: User[] = [] add(user: User): void &#123; //解构赋值 user = &#123;...user, id: Date.now()&#125; this.data.push(user) console.log('保存user', user.id) &#125; getById(id: number): User &#123; return this.data.find(item =&gt; item.id===id) &#125; &#125; const userCRUD = new UserCRUD() userCRUD.add(new User('tom', 12)) //保存user 1617067853995 userCRUD.add(new User('tom2', 13)) //保存user 1617067894390 console.log(userCRUD.data) //&#123;name: \"tom\", age: 12, id: 1617067901231&#125; &#123;name: \"tom2\", age: 13, id: 1617067901233&#125;&#125;)() 泛型类在定义类时, 为类中的属性或方法定义泛型类型 在创建类的实例时, 再指定特定的泛型类型 泛型约束如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性 1234567891011121314// 没有泛型约束function fn &lt;T&gt;(x: T): void &#123; // console.log(x.length) // error&#125;interface Lengthwise &#123; length: number;&#125;// 指定泛型约束function fn2 &lt;T extends Lengthwise&gt;(x: T): void &#123; console.log(x.length)&#125;fn2('abc')// fn2(123) // error number没有length属性","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"ts函数","slug":"TypeScript/ts函数","date":"2021-03-29T13:56:06.000Z","updated":"2021-03-29T14:24:56.887Z","comments":true,"path":"2021/03/29/TypeScript/ts函数/","link":"","permalink":"http://yoursite.com/2021/03/29/TypeScript/ts函数/","excerpt":"","text":"ts函数实现抽象层，模拟类，信息隐藏和模块 12345678910111213141516//我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型function add(x: number, y: number): number &#123; return x + y&#125;let myAdd = function(x: number, y: number): number &#123; return x + y&#125;//函数完整写法//myAdd2 变量名//(x: number, y: number) =&gt; number 函数类型//function 函数类型的值let myAdd2: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y&#125; 可选参数和默认参数1、TypeScript 里的每个函数参数都是必须的 2、这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值 3、传递给一个函数的参数个数必须与函数期望的参数个数一致 4、JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined 5、TypeScript 里可以在参数名旁使用 ? 实现可选参数的功能 123456789function getFullname(firstName: string=\"zhang\", lastName?: string):string &#123; if(lastName) &#123; return firstName + \"_\" + lastName &#125; return firstName&#125;console.log(getFullname(\"zhang\", 'san')) //zhang_sanconsole.log(getFullname(\"zhao\")) //zhao 剩余参数123456//...args: xxx[] 剩余参数 ， 要放在参数最后function showStr(str: string, ...args: string[]) &#123; console.log(str) //a console.log(...args) //b c d&#125;showStr('a', 'b', 'c', 'd') 函数重载1234567891011121314151617181920212223//感觉用于自己写的工具函数会好一点，不直接涉及用户交互//函数重载声明function add(x: number, y: number): numberfunction add(x: string, y: string): stringfunction add(x: number | string, y: number | string): number | string &#123; if(typeof x == 'string' &amp;&amp; typeof y == 'string') &#123; return x + y //字符串拼接 &#125;else if(typeof x == 'number' &amp;&amp; typeof y == 'number') &#123; return x + y //数字相加 &#125; //else &#123;// 其他直接返回一个值 不行？？？ //return \"can not do it\" //&#125;&#125;console.log(add(1 , 2)) //3console.log(add(\"东方\" , \"不败\")) //东方不败//未声明重载前// console.log(add(\"东方\" , 1)) //undefined//声明重载后直接报错// console.log(add(\"东方\" , 1))","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"ts类","slug":"TypeScript/ts类","date":"2021-03-29T08:42:04.000Z","updated":"2021-03-29T13:55:37.533Z","comments":true,"path":"2021/03/29/TypeScript/ts类/","link":"","permalink":"http://yoursite.com/2021/03/29/TypeScript/ts类/","excerpt":"","text":"ts类 （和java基本一样）12345678910111213141516171819202122232425(() =&gt; &#123; //父类 class Person &#123; name: string age: number sex: string //可以给默认值 constructor(name: string, age: number=1) &#123; this.name = name this.age = age &#125; say(str:string) &#123; console.log(\"class say no \" + this.name + \" \" + str) &#125; run(distance: number=10) &#123; console.log(this.name + \" run \" + distance) &#125; &#125; var person:Person = new Person(\"zs\") // Person.prototype.sex = \"man\" // //person.sex = \"man\" // console.log(person.sex) //man person.say('father') //class say no zs father&#125;)() 继承12345678910111213141516171819//子类class CPerson extends Person &#123; constructor(name: string, age: number=1) &#123; super(name, age); &#125; say(str:string) &#123; console.log(\"CPerson \" + str) super.say('children') &#125; run(distance: number=100) &#123; console.log(this.name + \" run \" + distance) &#125; &#125; var cp:CPerson = new CPerson(\"ls\") // CPerson.prototype.sex = 'woman' // cp.sex = \"woman\" // console.log(cp.sex) //woman cp.say(\"child\") //CPerson child CPerson class say no ls 多态1234567891011121314151617//父类的引用指向子类对象，不同类型的子类针对相同方法产生不同的行为class CCPerson extends Person &#123; constructor(name: string, age: number=1) &#123; super(name, age); &#125; run(distance: number = 1000) &#123; console.log(this.name + \" run \" + distance) &#125;&#125;var ccp:CCPerson = new CCPerson('ww')var cp1:Person = new CPerson(\"zl\") //使用父类型创建子类对象var ccp1:Person = new CCPerson(\"qq\")person.run() //zs run 10cp.run() //ls run 100ccp.run() //ww run 1000cp1.run() //zl run 100ccp1.run() //qq run 1000 修饰符protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 访问修饰符: 用来描述类内部的属性/方法的可访问性 public: 默认值, 公开的外部也可以访问 private: 只能类内部可以访问 protected: 类内部和子类可以访问*/class Animal &#123; public name: string public constructor (name: string) &#123; this.name = name &#125; public run (distance: number=0) &#123; console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`) &#125;&#125;class Person extends Animal &#123; private age: number = 18 protected sex: string = '男' run (distance: number=5) &#123; console.log('Person jumping...') super.run(distance) &#125;&#125;class Student extends Person &#123; run (distance: number=6) &#123; console.log('Student jumping...') console.log(this.sex) // 子类能看到父类中受保护的成员 // console.log(this.age) // 子类看不到父类中私有的成员 super.run(distance) &#125;&#125;console.log(new Person('abc').name) // 公开的可见// console.log(new Person('abc').sex) // 受保护的不可见// console.log(new Person('abc').age) // 私有的不可见 readonly使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 1234567891011121314class Person &#123; readonly name: string = 'abc' constructor(name: string) &#123; this.name = name &#125;&#125;//参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。class Person &#123; //仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处 constructor(readonly name: string) &#123; this.name = name &#125;&#125; 存取器 getter 和 setter控制对对象成员的访问 123456789101112131415161718192021222324252627282930313233343536373839/* 静态属性, 是类对象的属性非静态属性, 是类的实例对象的属性*/(() =&gt; &#123; class Person &#123; //类中有一个默认的name属性,所以下行代码会报错 // static name : string firstName: string = 'A' lastName: string = 'B' static sex: string = \"man\" constructor(firstName:string, lastName:string) &#123; this.firstName = firstName this.lastName = lastName &#125; get fullName () &#123; return this.firstName + '-' + this.lastName &#125; set fullName (value) &#123; const names = value.split('-') this.firstName = names[0] this.lastName = names[1] &#125; static say() &#123; console.log(\"static function\") &#125; &#125; const p = new Person(\"东方\",\"不败\") console.log(p.fullName) //东方-不败 // console.log(p.sex)// 报错 console.log(Person.sex)// man Person.sex = \"woman\" console.log(Person.sex)// woman Person.say() //static function p.fullName = '东方-不败' //东方 不败 console.log(p.firstName, p.lastName)&#125;)() 抽象类1、抽象类做为其它派生类的基类使用。 它们不能被实例化 2、不同于接口，抽象类可以包含成员的实现细节 3、abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法 123456789101112131415161718192021222324(() =&gt; &#123; abstract class Animal &#123; //抽象属性 abstract name:string = \"animal\" // 抽象类， 不能有具体实现 abstract eat() //实例方法 say() &#123; console.log(\"mou mou\") &#125; &#125; //不能直接实例话 // var animal:Animal = new Animal() class Dog extends Animal &#123; name:string = \"animal\" eat() &#123; console.log(\"dog dog\") &#125; &#125; var dog:Animal = new Dog() dog.eat() //dog dog dog.say() //mou mou console.log(dog.name) //animal&#125;)()","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"ts接口","slug":"TypeScript/ts接口","date":"2021-03-29T07:37:26.000Z","updated":"2021-03-29T09:31:48.188Z","comments":true,"path":"2021/03/29/TypeScript/ts接口/","link":"","permalink":"http://yoursite.com/2021/03/29/TypeScript/ts接口/","excerpt":"","text":"ts接口TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述) 123456789101112131415// 定义人的接口interface IPerson &#123; readonly id: number //只读 name: string age: number sex？: string //可选属性&#125;const person1: IPerson = &#123; id: 1, name: 'tom', age: 20,&#125;person1.id = 10 //编译不通过person1.sex = 'man' ts函数类型为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 123456789101112131415/* 接口可以描述函数类型(参数的类型与返回的类型)*/interface SearchFunc &#123; //定义一个调用签名 //它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型 (source: string, subString: string): boolean&#125;const mySearch: SearchFunc = function (source: string, sub: string): boolean &#123; return source.search(sub) &gt; -1&#125;console.log(mySearch('abcd', 'bc')) //true 类类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//和java相似 继承 实现/* 类类型: 实现接口1. 一个类可以实现多个接口2. 一个接口可以继承多个接口*/(() =&gt; &#123; //定义一个接口 interface Ifly &#123; //定义一个没有任何实现的方法 fly():void &#125; class Fly implements Ifly &#123; fly() &#123; console.log('fly') &#125; &#125; var fly = new Fly() fly.fly() interface Ifly2 &#123; //定义一个没有任何实现的方法 fly2():void &#125; class Fly2 implements Ifly, Ifly2 &#123; fly() &#123; console.log('fly1') &#125; fly2() &#123; console.log('fly2') &#125; &#125; var fly2 = new Fly2() fly2.fly() fly2.fly2() interface Ifly3 extends Ifly, Ifly2 &#123; &#125; class Fly3 implements Ifly3 &#123; fly() &#123; console.log('fly3') &#125; fly2() &#123; console.log('fly3') &#125; &#125; var fly3 = new Fly3() fly3.fly() fly3.fly2()&#125;)()","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"js数组操作","slug":"js/js数组操作","date":"2021-03-29T02:37:26.000Z","updated":"2021-04-28T11:20:16.298Z","comments":true,"path":"2021/03/29/js/js数组操作/","link":"","permalink":"http://yoursite.com/2021/03/29/js/js数组操作/","excerpt":"","text":"js数组操作常用1234567891011push()：向数组的末尾添加一个或多个元素，并返回新的长度pop()：删除数组的最后一个元素，数组的长度减1，并且返回删除元素的值(数组为空时，不改变数组，并返回undefined)unshift()：向数组的头部添加一个或多个元素，返回新的长度shift()：删除并返回数组的第一个元素reverse()：颠倒数组中的元素顺序indexOf(x, start)、lastIndexOf()：查找数组元素的位置，参数：要查的项和起点位置索引 排序 sort =&gt; 对数组元素进行排序（默认按照ASCII）123456789101112131415161718192021222324252627282930313233343536373839404142434445var arr = [10,5,1000,25,1];arr.sort(); // [1, 10, 1000, 25, 5] 默认按照首字母顺序排arr.sort((a, b)=&gt;&#123; return a-b;&#125;); // [1, 5, 10, 25, 1000] 从大到小排序 /** * @function 指定数组排序规则 * @param str &#123;Array&#125; 单个属性 * @param num &#123;Number&#125; 是否升序 默认降序 * @version 1.0.0 * @description 用于图表的排序 */sortBy() &#123; let num = 1 let arr = [] //最后一个参数是数字 if(typeof arguments[arguments.length - 1] === 'number' &amp;&amp; !isNaN(arguments[arguments.length - 1])) &#123; //获取最后一个参数的值 num = arguments[arguments.length - 1] ? 1 : -1 arr = arguments.slice(0, arguments.length - 1) &#125;else &#123;//最后一个参数不是数字 arr = arguments &#125; // num = num ? 1 : -1 return function(a,b)&#123; // 获取其他参数的值 let a1 = 0 let b1 = 0 for(var i = 0, len = arr.length; i &lt; len; i++) &#123; a1 += a[arr[i]] b1 += b[arr[i]] &#125; if(a1 &gt; b1)&#123; return num * -1; &#125; if(a1 &lt; b1)&#123; return num * 1; &#125; return 0; &#125;&#125;//使用data.sort(this.sortBy('isLeader', 'isNotLeader')) concat()：链接两个或多个数组123456//该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。arrayObject.concat(arrayX,arrayX,......,arrayX)//可用于对数组进行深拷贝 （不行）//数组中的对象等还是没有进行深拷贝var arr1 = [].concat(arr) join =&gt; 把所有的元素放进一个字符串，通过指定的分隔符分割1234var arr = [1,2,3]arr.join('-') //\"1-2-3\"var arr1 = []arr1.join(\"-\")//\"\" splice =&gt; 删除元素，并向数组添加新元素12345678var arr = [1, 2, 3, 4, 5, 6];arr.splice(2, 3); // [3, 4, 5] 删除第三个元素以后的三个数组元素 arr.splice(2, 0, 7, 8); // [] 在第三个元素之前插入7和8arr; // [1, 2, 7, 8, 9] arr.splice(2, 3, 9, 10); // [7, 8, 9] 删除第三个元素以后的三个数组元素，并用9和10代替arr; // [1, 2, 9, 10] slice(start, end) =&gt; 从某个已有的数组返回选定的元素(没有end参数时就到数组结尾)123456789//该方法返回一个新的数组，包含从 start 到 end （不包括该元素，数学上来讲是左闭右开，即包含左，不含右）的 arrayObject 中的元素//可用于数组深拷贝(不行)//不会影响原数组////数组中的对象等还是没有进行深拷贝var arr1 = [1, 2, 3];var arr2 = arr1.slice(0);arr1[0] = 4;console.log(arr1); //4, 2, 3console.log(arr2); //1, 2, 3 深拷贝12345678910111213141516171819function getType(o)&#123; var _t; return ((_t = typeof(o)) == \"object\" ? o==null &amp;&amp; \"null\" || Object.prototype.toString.call(o).slice(8,-1):_t).toLowerCase();&#125;function extend(destination,source)&#123; for(var p in source)&#123; if(getType(source[p])==\"array\"||getType(source[p])==\"object\")&#123; destination[p]=getType(source[p])==\"array\"?[]:&#123;&#125;; arguments.callee(destination[p],source[p]); &#125;else &#123; destination[p]=source[p]; &#125; &#125;&#125;var test=&#123;a:\"ss\",b:\"dd\",c:&#123;d:\"css\",e:\"cdd\"&#125;&#125;;var test1=&#123;&#125;;extend(test1,test);test1.c.d=\"change\"; //改变test1的c属性对象的d属性alert(test.c.d); //不影响test 数组中的两个元素交换位置1234567891011/*** 数组元素交换位置* @param &#123;array&#125; arr 数组* @param &#123;number&#125; index1 添加项目的位置* @param &#123;number&#125; index2 删除项目的位置* index1和index2分别是两个数组的索引值，即是两个要交换元素位置的索引值，如1，5就是数组中下标为1和5的两个元素交换位置*/function swapArray(arr, index1, index2) &#123; arr[index1] = arr.splice(index2, 1, arr[index1])[0]; return arr;&#125; 根据数组中对象的属性值查询该对象所在角标1var index = subArr .findIndex(function (item) &#123; return item.proId === proid; &#125;);","categories":[],"tags":[{"name":"js 数组","slug":"js-数组","permalink":"http://yoursite.com/tags/js-数组/"}]},{"title":"js遍历数组","slug":"js/js遍历数组","date":"2021-03-29T02:20:04.000Z","updated":"2021-03-30T01:44:10.070Z","comments":true,"path":"2021/03/29/js/js遍历数组/","link":"","permalink":"http://yoursite.com/2021/03/29/js/js遍历数组/","excerpt":"","text":"JS 遍历数组1.普通for循环123for (i = 0; i &lt; loopTimes; i++) &#123; console.log(i);&#125; 2.弱化for循环123for(j = 0; arr[j]!=null; j++) &#123;&#125; 3.foreach循环方法对数组的每个元素执行一次提供的函数。总是返回undefined 1234567//forEach方法中的function回调有三个参数：//第一个参数是遍历的数组内容，//第二个参数是对应的数组索引，//第三个参数是数组本身,可用this调用head.forEach(function (element, index, arr) &#123; element.checked = true;&#125;); 4.foreach变种document.querySelectorAll()返回的并不是我们想当然的数组(对数组进行解析是html的每个元素节点列表，使用getElementsByTagNames()也是一样)，而是NodeList，对NodeList，它里面没有.forEach方法，我们使用了这样的方法进行循环: 123456789101112//调用数组的原型相关方法Array.prototype.forEach.call(arr,function(el)&#123; &#125;);//简写[].prototype.forEach.call(arr,function(el, index, arr1)&#123; &#125;);//参数//arr 传入的参数NodeList//.call() 用arr替换[]作为传入参数//其余参数和foreach一样 5.for in循环（不建议使用）1).index索引为字符串型数字，不能直接进行几何运算。 2).遍历顺序有可能不是按照实际数组的内部顺序。 3).使用for in会遍历数组所有的可枚举属性，包括原型。 缺点：给数组添加了原型函数，导致循环的结果多了一个函数。将Array数组的原型添加了方法，导致循环的时候将该方法也遍历到了，所以for…in…循环最好使用在遍历对象上，不要用来遍历数组。 123for(var i in arr) &#123;&#125; 6.for of 循环 （可遍历Symbol）https://www.cnblogs.com/wangxiayun/p/10194806.htmlfor…of是ES6新增的遍历方式，它提供了统一的遍历机制。所有实现了[Symbol.iterator]接口的对象都可以被遍历。for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。 优点： 有着同for...in一样的简洁语法，但是没有for...in那些缺点 不同用于forEach方法，它可以与break、continue和return配合使用 提供了遍历所有数据结构的统一操作接口 12345678let j = 0for(var i of this.hasSelectedList) &#123; if(this.hasSelectedList[i] == id) &#123; j = i break; &#125;&#125;this.hasSelectedList.splice(j,1) for…of获取索引 entries返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys返回一个遍历器对象，用来遍历所有的键名。 values返回一个遍历器对象，用来遍历所有的键值。 1234let arr = ['a', 'b', 'c']; for (let pair of arr.entries) &#123; console.log(pair); &#125; // [0, 'a'] // [1, 'b'] // [2, 'c'] 类似数组的对象类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList 对象、arguments对象的例子。 123456789101112131415// 字符串 let str = \"hello\"; for (let s of str) &#123; console.log(s); // h e l l o &#125; // DOM NodeList对象 let paras = document.querySelectorAll(\"p\");for (let p of paras) &#123; p.classList.add(\"test\"); &#125; // arguments对象 function printArgs &#123; for (let x of arguments) &#123; console.log(x); &#125; &#125; printArgs('a', 'b'); // 'a' // 'b' 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 12345678910111213let arrayLike = &#123; length: 2, 0: &apos;a&apos;, 1: &apos;b&apos; &#125;; // 报错for (let x of arrayLike) &#123; console.log(x); &#125; // 正确 for (let x of Array.from(arrayLike)) &#123; console.log(x); // &apos;a&apos; // &apos;b&apos;&#125; 普通的对象对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。 1234567891011let es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\" &#125;; for (let e in es6) &#123; console.log(e); &#125; // edition // committee // standard for (let e of es6) &#123; console.log(e); &#125; // TypeError: es6 is not iterable 解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 12345678let es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\" &#125;;for (var key of Object.keys(es6)) &#123; console.log(key + ': ' + es6[key]); &#125; 7、map调用的数组的每个元素传递给指定的函数，并返回一个数组 12345678910111213141516171819var arr = [1,2,3,4,5,6]var newArr1 = arr.map(x =&gt; x % 2 == 0 ? x % 2 : x)console.log(newArr1) //[1, 0, 3, 0, 5, 0]//map()方法创建了一个新数组，但新数组并不是在遍历完arr后才被赋值的，而是每遍历一次就得到一个值var newArr2 = arr.map(x =&gt; &#123; if (x % 2 == 0) &#123; return x % 2; &#125;&#125;)console.log(newArr2) //[undefined, 0, undefined, 0, undefined, 0]var newArr3 = arr.map(x =&gt; &#123; if (x % 2 == 0) &#123; return x % 2; &#125; return x;&#125;)console.log(newArr3) //[1, 0, 3, 0, 5, 0] 8、filter参考： https://www.jianshu.com/p/494226d9dd2cfilter用于对数组进行过滤。它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意：filter()不会对空数组进行检测、不会改变原始数组 12345678910111213//函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留；//函数的第一个参数 currentValue 也为必须，代表当前元素的值。//函数的第二个参数 index 为数组索引。//函数的第三个参数 arr 为当前数组。Array.filter(function(currentValue, indedx, arr), thisValue)let arr = [1, 2, 3, 4, 5, 6];let newArr = arr.filter(value =&gt; value % 2 == 0);console.log(newArr) //[2, 4, 6]let ar1 = []let newArr1 = arr.filter(value =&gt; value % 2 == 0);console.log(newArr) //[] 9、every123//数组的每一项都满足给定条件则返回truearr = [1, 2, 3, 4];arr.every((item,index,array) =&gt; &#123;return item &gt; 2;&#125;); // false 10、some12//数组中只要有一项满足条件就返回truearr.some((item,index,array) =&gt; &#123;return item &gt; 2;&#125;); //true 11、reduce参考https://www.jianshu.com/p/e375ba1cfc4712、find findIndexfind 返回通过测试的数组的第一个元素的值 在第一次调用 callback 函数时会确定元素的索引范围，因此在 find 方法开始执行之后添加到数组的新元素将不会被 callback 函数访问到。如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍旧会被访问到 123//value:必须，代表当前元素，其他四个参数都是可选，index代表当前索引值，arr代表当前的数组，thisValue代表传递给函数的值，一般用this值，如果这个参数为空，undefined会传递给this值//返回值：返回符合测试条件的第一个数组元素的值，如果没有符合条件的则返回undefined。array.find(function(value, index, arr),thisValue) findIndex方法传入一个测试条件（函数），返回符合条件的数组第一个元素位置（index） 方法为数组中的每个元素都调用一次函数执行 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1","categories":[],"tags":[{"name":"js 数组","slug":"js-数组","permalink":"http://yoursite.com/tags/js-数组/"}]},{"title":"页面传参","slug":"html/页面传参","date":"2021-03-29T01:37:30.000Z","updated":"2021-04-19T09:47:49.459Z","comments":true,"path":"2021/03/29/html/页面传参/","link":"","permalink":"http://yoursite.com/2021/03/29/html/页面传参/","excerpt":"","text":"HTML vue 页面跳传参 一、html ——– 通过url， js 参考：https://blog.csdn.net/qq_27628085/article/details/90763963 123456789101112131415161718192021222324252627282930313233343536373839404142//改变当前页面， url 可以拼接参数window.location.href='hello.html'//接收页面传值方法//window.location.search 为 ？及以后的部分function getParams(key) &#123; var reg = new RegExp(\"(^|&amp;)\" + key + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null; &#125;;//第一个参数是要打开的页面的url,第二个参数是窗口目标，第三个参数是一个特定字符串以及一个表示新页面是否取代浏览器历史集中当前加载页面的布尔值，通常只需要传递第一个参数。第二个参数还可以是”_blank”,”_self”,”_parent”,”_top”这样的特殊窗口名称，”_blank”打开新窗口,”_self”实现的效果同window.location.href.window.open(url, string，boolean)//弹窗可能被屏蔽，有两种情况//1.浏览器内置的屏蔽程序阻止弹出窗口，那么 window.open()很可能返回Null，此时，只要监测这个返回的值就可以确定弹出窗口是否被屏蔽var newWin = window.open(url);if(newWin == null)&#123; alert(\"弹窗被阻止\");&#125;//2.浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误，因此，要像准确的检测弹出窗口是否被屏蔽，必须在检测返回值的同时，将window.open()封装在try-catch块中&lt;script&gt; var blocked = false; try&#123; var index = \"lemon\"; var url = \"receive.html?index=\"+index; $(\"#more\").click(function()&#123; var newWin = window.open(url); if(newWin == null)&#123; blocked = true; &#125; &#125;); &#125; catch(ex)&#123; block = true; &#125; if(blocked)&#123; alert(\"弹出窗口被阻止\"); &#125; &lt;/script&gt; 二、通过localStorage 和 sessionStorage 先存本地再取出数据 12345678910111213141516171819//localStorage是持久化的本地保存，只要你找不到其所在地没有主动删掉，就会一直存在。//sessionStorage是会话级别的本地保存，比如一个页面关闭的时候该页面设置的sessionStorage数据会自动消失，在不同浏览器窗口不会共享的，即使是同一个浏览器的同一个页面。当会话结束，sessionstroage保存值也会清空。//用setItem来存数据，第一个参数是 名字，第二个参数是存数的数据//存数据window.localStorage.setItem(“data”, “kevin”);window.sessionStorage.setItem(“data”, “kevin”);//用getItem来取数据，参入要取数据的 名字就好//取数据window.localStorage.getItem(“data”);window.sessionStorage.getItem(“data”);//当然如果要存储的数据是一个对象的话，就需要将对象转换为字符串，在取数据的在将字符串转为对象就可以了//对象转字符串 JSON.stringify( ” 对象 ” )//字符串转对象 JSON.parse( ” 字符串 ” ) 三、通过cookie, 具体可参考参考链接 1234567891011//cookie前端与后台都可以创建保存在客户端,有默认有效时间,当然也可以清除浏览器cookie;//创建方式,cookie键值对以等号方式连接cookie之间用分号分开;var name=\"liuliu\";var age=28;document.cookie=\"name=\"+name;document.cookie=\"age=\"+age;//获取全部cookie字符串:document.cookie; 四、vue 1、params 相当于post请求，页面跳转时参数不会在地址栏中显示 12345678910111213141516171819202122//使用params传参时 刷新页面参数消失this.$router.push(&#123;path: `/describe/$&#123;id&#125;`&#125;)//路由配置&#123; path: '/describe/:id', name: 'Describe', component: Describe&#125;//通过路由属性中的name来确定匹配的路由，通过params来传递参数// 路由正常配置即可// 配置时：添加:/id 也可以不添加，不添加数据会在url后面显示，不添加数据就不会显示this.$router.push(&#123; //params传参 需要使用 name 否则取不到；对应路由配置的 name name: 'Describe', params: &#123; id: id &#125; &#125;)//接收参数this.$route.params.id 2、query 相当于get请求，页面跳转时参数会在地址栏中显示 12345678910111213141516171819202122232425//使用path来匹配路由，然后通过query来传递参数；这种情况下 query传递的参数会显示在url后面?id=？this.$router.push(&#123; path: '/describe', query: &#123; id: id &#125; &#125;)//子组件接收参数： this.$route.query.id/* 参数获取，params和query区别，query参数在地址栏显示，params的参数不在地址栏显示*///和push的区别，push有记录一个history，replace没有//在本页面替换this.$router.replace(&#123;name: '/detail', params: &#123;id: e&#125;&#125;)//resolve页面跳转可用新页面打开//2.1.0版本后，使用路由对象的resolve方法解析路由，可以得到location、router、href等目标路由的信息。得到href就可以使用window.open开新窗口了（这边应用：https://segmentfault.com/q/1010000009557100下的一个回答）const new = this.$router.resolve(&#123;name: '/detail', params: &#123;id: e&#125;&#125;)window.open(new.href,'_blank')window.opener() //获取父窗口对象，没有则为null 3.、修改路由的query参数 12345678910111213141516//安装 webpack-mergenpm i webpack-merge//导入 webpack-mergeimport merge from 'webpack-merge';//修改原有参数this.$router.push(&#123; query:merge(this.$route.query,&#123;'auditedDeptId':this.ruleForm.auditedDeptId&#125;)&#125;)//新增一个参数this.$router.push(&#123; query:merge(this.$route.query,&#123;'newParams':'new'&#125;)&#125;)//替换所有参数 this.$router.push(&#123; query:merge(&#123;&#125;,&#123;'maxPrice':'630'&#125;)&#125;)","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"ts使用","slug":"TypeScript/ts使用","date":"2021-03-26T08:33:51.000Z","updated":"2021-03-29T07:36:13.694Z","comments":true,"path":"2021/03/26/TypeScript/ts使用/","link":"","permalink":"http://yoursite.com/2021/03/26/TypeScript/ts使用/","excerpt":"一、基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用123//变量//一开始赋值什么类型就只能使用什么类型let xx:类型 = yy;","text":"一、基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用123//变量//一开始赋值什么类型就只能使用什么类型let xx:类型 = yy; 1、布尔型123//布尔类型let flag:boolean = trueconsole.log(flag); 2、数字类型12345678910//数字类型let a1: number = 10 // 十进制let a2: number = 0b1010 // 二进制let a3: number = 0o12 // 八进制let a4: number = 0xa // 十六进制console.log(a1); //10console.log(a2); //10console.log(a3); //10console.log(a4); //10 3、字符串类型1234//字符串类型let str:string = 'zs'console.log(str); //zsconsole.log(str + a1); // zs10 4、 undefined 和 null12345678910// undefined 和 null 都可以作为其他类型的子类型let u: undefined = undefinedlet n: null = nullconsole.log(u); //undefinedconsole.log(n); //null//在严格模式下会报错//在 tsconfig.json 下设置 \"strict\": false, let num:number = undefinedconsole.log(num); //undefined 5、数组typeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组123let list1: number[] = [1, 2, 3] //数组定义后里面的数据类型就固定了//泛型let list2: Array&lt;number&gt; = [1, 2, 3] 6、元组(Tuple)1234//定义数组时，类型和数组的个数一开始就确定了let list3:[string, number, boolean] = ['zs', 12, false]console.log(list3); //['zs', 12, false]// console.log(list3[1].startsWith(12)); 直接报错 7、枚举类型123456789101112131415161718192021222324252627282930313233343536373839404142//enum 类型是对 JavaScript 标准数据类型的一个补充//枚举里面的每个数据都可以称为元素，有从0开始的编号enum Color &#123; Red, Green, Blue &#125;// 枚举数值默认从0开始依次递增// 根据特定的名称得到对应的枚举数值let myColor: Color = Color.Green // 0console.log(myColor, Color.Red, Color.Blue) // 1 0 2//可以手动改变值//全部手动赋值enum Color1 &#123; Red = 10, Green = 100, Blue = 50 &#125;console.log(Color1，Color1.Red, Color1.Green, Color1.Blue) // &#123;10: \"Red\", 50: \"Blue\", 100: \"Green\", Red: 10, Green: 100, Blue: 50&#125; 10 100 50//手动赋值第一二个enum Color1 &#123; Red = 100, Green = 50, Blue &#125;console.log(Color1，Color1.Red, Color1.Green, Color1.Blue) //&#123;50: \"Green\", 51: \"Blue\", 100: \"Red\", Red: 100, Green: 50, Blue: 51&#125; 100 50 51//手动赋值第一二个enum Color1 &#123; Red = 51, Green = 50, Blue &#125;console.log(Color1，Color1.Red, Color1.Green, Color1.Blue) //&#123;50: \"Green\", 51: \"Blue\", Red: 51, Green: 50, Blue: 51&#125; 51 50 51console.log(Color1[2]); //undefinedconsole.log(Color1[51]); //Blue 8、any (anyScript)12let list: any[] = [1, true, 'free']list[1] = 100 9、void123456789101112131415//某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void；总是返回undefinedfunction noReturn(a:string):void &#123; return undefined&#125;console.log(noReturn('aaa')) //undefinedfunction noReturn(a:string):void &#123; return null&#125;console.log(noReturn('aaa')) //null//以下编译不通过function noReturn(a:string):void &#123; return a&#125; 10、objectobject 表示非原始类型，也就是除 number，string，boolean之外的类型。 123456789function fn2(obj:object):object &#123; console.log('fn2()', obj) return &#123;&#125; // return undefined // return null&#125;console.log(fn2(new String('abc')))// console.log(fn2('abc') // errorconsole.log(fn2(String)) 11、联合类型123function fn(x: number | string) &#123; return x.toString()&#125; 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 1234567891011121314151617/* 类型断言(Type Assertion): 可以用来手动指定一个值的类型语法: 方式一: &lt;类型&gt;值 方式二: 值 as 类型 tsx中只能用这种方式*//* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */function getLength(x: number | string) &#123; if ((&lt;string&gt;x).length) &#123; // return (&lt;string&gt;x).length return (x as string).length &#125; else &#123; return x.toString().length &#125;&#125;console.log(getLength('abcd'), getLength(1234)) // 4,4 类型推断TS会在没有明确的指定类型的时候推测出一个类型 12345678910/* 定义变量时赋值了, 推断为对应的类型 */let x = 123 // number// x = 'abc' // error/* 定义变量时没有赋值, 推断为any类型 */let y // any类型console.log(y) //undefinedconsole.log(typeof y) //undefinedy = 123y = 'abc'","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"ts","slug":"TypeScript/ts","date":"2021-03-26T06:20:54.000Z","updated":"2021-03-27T13:30:50.104Z","comments":true,"path":"2021/03/26/TypeScript/ts/","link":"","permalink":"http://yoursite.com/2021/03/26/TypeScript/ts/","excerpt":"初步认识引用：https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html一、初始1.ts文件直接写js代码，在html代码中可以直接使用（我自己实验不行，必须进行编译）2.ts函数形参使用类型修饰符，在编译后不会出现3.ts使用 let 进行修饰，编译后变成 var","text":"初步认识引用：https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html一、初始1.ts文件直接写js代码，在html代码中可以直接使用（我自己实验不行，必须进行编译）2.ts函数形参使用类型修饰符，在编译后不会出现3.ts使用 let 进行修饰，编译后变成 var 二、自动编译12345671). 生成配置文件tsconfig.json tsc --init2). 修改tsconfig.json配置 \"outDir\": \"./js\", //生成在js目录下 \"strict\": false, 3). 启动监视任务: 终端 -&gt; 运行任务 -&gt; 监视tsconfig.json 三、类型注解TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。可以编译但是会警告你代码可能不会按预期执行。四、webpack打包ts1、入口JS: src/main.ts2、index页面: public/index.html3、webpack配置文件build/webpack.config.js4、下载依赖12345npm install -D typescriptnpm install -D webpack@4.41.5 webpack-cli@3.3.10 webpack-dev-server@3.10.2npm install -D html-webpack-plugin clean-webpack-pluginnpm install -D ts-loadernpm install -D cross-env 5、配置打包命令12345678910//\"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js\",//\"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\"//package.json 下\"scripts\": &#123; \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js\", \"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, 6、运行与打包12npm run devnpm run build 报错解决12345Cannot read property 'tap' of undefined at webpack (F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack\\lib\\webpack.js:51:13) at startDevServer (F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js:94:16) at F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js:166:3 at F:\\vue-ts\\01_TypeScript\\03_webpack_ts\\node_modules\\webpack-dev-server\\lib\\utils\\processOptions.js:33:9 1234567891011//原因：webpack版本 html-webpack-plugin版本不匹配//解决：先降级html-webpack-plugin 至4.0.0npm uninstall html-webpack-plugin -Dnpm install html-webpack-plugin@4.0.0 -D//仍不解决，可能是webpack全局版本覆盖了局部版本//重新安装webpack 和webpack-clinpm uninstall webpack webpack-cli -gnpm install webpack@4.41.5 webpack-cli@3.3.10 -g//在局部安装npm install webpack@4.41.5 webpack-cli@3.3.10 -D","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]}],"categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"reactreact旧生命周期","slug":"reactreact旧生命周期","permalink":"http://yoursite.com/tags/reactreact旧生命周期/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"scss","slug":"scss","permalink":"http://yoursite.com/tags/scss/"},{"name":"vue3","slug":"vue3","permalink":"http://yoursite.com/tags/vue3/"},{"name":"vue-el踩坑","slug":"vue-el踩坑","permalink":"http://yoursite.com/tags/vue-el踩坑/"},{"name":"vue-Router","slug":"vue-Router","permalink":"http://yoursite.com/tags/vue-Router/"},{"name":"Element UI","slug":"Element-UI","permalink":"http://yoursite.com/tags/Element-UI/"},{"name":"Vue3","slug":"Vue3","permalink":"http://yoursite.com/tags/Vue3/"},{"name":"Ty","slug":"Ty","permalink":"http://yoursite.com/tags/Ty/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"js 数组","slug":"js-数组","permalink":"http://yoursite.com/tags/js-数组/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]}